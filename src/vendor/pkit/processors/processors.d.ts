import type { FromEventTarget } from 'rxjs/internal/observable/fromEvent';
import type { Sink, MappedWrapObservable } from 'pkit/core';
import { Observable, GroupedObservable } from 'rxjs';
export declare type UnwrapObservable<T> = T extends Observable<infer I> ? I : never;
export declare type MappedUnwrapObservable<T> = {
    [P in keyof T]: UnwrapObservable<T[P]>;
};
export declare const directProc: <T>(source$: Observable<T>, sink: Sink<T>) => Observable<import("pkit/core").PortMessage<T>>;
export declare const filterProc: <T>(source$: Observable<T>, sink: Sink<T>, fn: FilterFn<T>) => Observable<import("pkit/core").PortMessage<T>>;
declare type FilterFn<T> = (data: T) => boolean;
export declare const filterMapProc: <T, U, V extends U>(source$: Observable<T>, sink: Sink<U>, filterFn: FilterFn<T>, mapFn: MapFn<T, V>) => Observable<import("pkit/core").PortMessage<U>>;
declare type MapFn<T, U> = (data: T) => U;
export declare const mapProc: <T, U, V extends U>(source$: Observable<T>, sink: Sink<U>, fn: MapFn<T, V>) => Observable<import("pkit/core").PortMessage<U>>;
export declare const createMapProc: <T, U>(fn: (data: T) => U) => (source$: Observable<T>, sink: Sink<U>) => Observable<import("pkit/core").PortMessage<U>>;
export declare const mapFilterVoidProc: <T, U, V extends U>(source$: Observable<T>, sink: Sink<U>, fn: MapFn<T, V>) => Observable<import("pkit/core").PortMessage<U>>;
export declare const createMapFilterVoidProc: <T, U, V extends U = U>(fn: MapFn<T, V>) => (source$: Observable<T>, sink: Sink<U>) => Observable<import("pkit/core").PortMessage<U>>;
export declare const mapToProc: <T, U extends T>(source$: Observable<unknown>, sink: Sink<T>, data?: T | U | undefined) => Observable<import("pkit/core").PortMessage<T>>;
declare type MergeMapFn<T, U> = (data: T) => Observable<U> | Promise<U>;
export declare const mergeMapProc: <T, U, V extends U>(source$: Observable<T>, sink: Sink<U>, fn: MergeMapFn<T, V>, errSink?: Sink<Error> | undefined) => Observable<import("pkit/core").PortMessage<Error> | import("pkit/core").PortMessage<U>>;
export declare const createMergeMapProc: <T, U, V extends U = U>(fn: MergeMapFn<T, V>) => (source$: Observable<T>, sink: Sink<U>, errSink?: Sink<Error> | undefined) => Observable<import("pkit/core").PortMessage<Error> | import("pkit/core").PortMessage<U>>;
export declare const mapToBindProc: <T, U, V extends U>(source$: Observable<T>, sink: Sink<[T, (U | undefined)?]>, bindArg: V) => Observable<import("pkit/core").PortMessage<[T, (U | undefined)?]>>;
export declare const latestProc: <T>(source$: Observable<unknown>, sink: Sink<T>, latest$: Observable<T>) => Observable<import("pkit/core").PortMessage<T>>;
export declare const withLatestProc: <T, U extends readonly any[]>(source$: Observable<T>, sink: Sink<[T, ...U]>, latests$: MappedWrapObservable<U>) => Observable<import("pkit/core").PortMessage<[T, ...U]>>;
declare type LatestFn<T, U extends readonly any[], V> = (data: [T, ...U]) => V;
export declare const latestMapProc: <T, U, V extends readonly any[], W extends U = U>(source$: Observable<T>, sink: Sink<U>, latests$: MappedWrapObservable<V>, fn: LatestFn<T, V, W>) => Observable<import("pkit/core").PortMessage<U>>;
export declare const createLatestMapProc: <T, U, V extends readonly any[] = [], W extends U = U>(fn: LatestFn<T, V, W>) => (source$: Observable<T>, sink: Sink<U>, latests$?: MappedWrapObservable<V>) => Observable<import("pkit/core").PortMessage<U>>;
declare type LatestMergeMapFn<T, U extends readonly any[], V> = (data: [T, ...U]) => Observable<V> | Promise<V>;
export declare const latestMergeMapProc: <T, U, V extends readonly any[], W extends U = U>(source$: Observable<T>, sink: Sink<U>, latests$: MappedWrapObservable<V>, fn: MergeMapFn<[T, ...V], W>, errSink?: Sink<Error> | undefined) => Observable<import("pkit/core").PortMessage<Error> | import("pkit/core").PortMessage<U>>;
export declare const createLatestMergeMapProc: <T, U, V extends readonly any[], W extends U = U>(fn: LatestMergeMapFn<T, V, W>) => (source$: Observable<T>, sink: Sink<U>, latests$: MappedWrapObservable<V>, errSink?: Sink<Error> | undefined) => Observable<import("pkit/core").PortMessage<Error> | import("pkit/core").PortMessage<U>>;
export declare const fromEventProc: <T, U extends T>(source$: Observable<FromEventTarget<U>>, sink: Sink<T>, eventName: string) => Observable<import("pkit/core").PortMessage<T>>;
export declare const pickProc: <T, U, V extends U = U>(source$: Observable<T>, sink: Sink<U>, query: (data: T) => V, patch?: (data: V) => U) => Observable<import("pkit/core").PortMessage<U>>;
export declare const intervalMapToProc: <T, U extends T>(running$: Observable<boolean>, sink: Sink<T>, interval: number, data?: U | undefined) => Observable<import("pkit/core").PortMessage<T>>;
export declare const intervalLatestMapProc: <T, U extends readonly any[]>(running$: Observable<boolean>, sink: Sink<T>, fn: (data: U) => T, interval?: number, latests$?: MappedWrapObservable<U>) => Observable<import("pkit/core").PortMessage<T>>;
export declare const zipMergeMapProc: <T, U, V>(source$: Observable<T>, sink: Sink<V>, sources$: [Observable<U>], fn: (data: [T, U]) => Observable<V> | Promise<V>) => Observable<import("pkit/core").PortMessage<V>>;
export declare const groupProc: <T, U>(source$: Observable<T>, sink: Sink<GroupedObservable<U, T>>, groupFunc: (data: T) => U) => Observable<import("pkit/core").PortMessage<GroupedObservable<U, T>>>;
export declare const createGroupProc: <T, U>(groupFn: (data: T) => U) => (source$: Observable<T>, sink: Sink<GroupedObservable<U, T>>) => Observable<import("pkit/core").PortMessage<GroupedObservable<U, T>>>;
export declare const exposeGroupProc: <T, U>(source$: Observable<GroupedObservable<U, T>>, sink: Sink<T>, key: U) => Observable<import("pkit/core").PortMessage<T>>;
export {};
