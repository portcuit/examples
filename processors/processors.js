"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exposeGroupProc = exports.createGroupProc = exports.groupProc = exports.zipMergeMapProc = exports.intervalLatestMapProc = exports.intervalMapToProc = exports.pickProc = exports.fromEventProc = exports.createLatestMergeMapProc = exports.latestMergeMapProc = exports.createLatestMapProc = exports.latestMapProc = exports.withLatestProc = exports.latestProc = exports.mapToBindProc = exports.createMergeMapProc = exports.mergeMapProc = exports.mapToProc = exports.createMapFilterVoidProc = exports.mapFilterVoidProc = exports.createMapProc = exports.mapProc = exports.filterMapProc = exports.filterProc = exports.directProc = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
exports.directProc = (source$, sink) => source$.pipe(operators_1.map((data) => sink(data)));
exports.filterProc = (source$, sink, fn) => source$.pipe(operators_1.filter((data) => fn(data)), operators_1.map(data => sink(data)));
exports.filterMapProc = (source$, sink, filterFn, mapFn) => source$.pipe(operators_1.filter((data) => filterFn(data)), operators_1.map((data) => sink(mapFn(data))));
exports.mapProc = (source$, sink, fn) => source$.pipe(operators_1.map((data) => sink(fn(data))));
exports.createMapProc = (fn) => (source$, sink) => exports.mapProc(source$, sink, fn);
exports.mapFilterVoidProc = (source$, sink, fn) => source$.pipe(operators_1.map((data) => fn(data)), operators_1.filter((data) => data !== undefined), operators_1.map((data) => sink(data)));
exports.createMapFilterVoidProc = (fn) => (source$, sink) => exports.mapFilterVoidProc(source$, sink, fn);
exports.mapToProc = (source$, sink, data) => source$.pipe(operators_1.map(() => sink(data)));
const mergeMapOperator = (fn, sink, errSink) => operators_1.mergeMap((data) => rxjs_1.of(true).pipe(operators_1.mergeMap(() => fn(data)), operators_1.map((data) => sink(data)), operators_1.catchError(err => errSink ? rxjs_1.of(errSink(err)) : rxjs_1.throwError(err))));
exports.mergeMapProc = (source$, sink, fn, errSink) => source$.pipe(mergeMapOperator(fn, sink, errSink));
exports.createMergeMapProc = (fn) => (source$, sink, errSink) => exports.mergeMapProc(source$, sink, fn, errSink);
// TODO: mapToFlatBindProc みたいなのもあるといいかもね。でもそもそもmapProcで間に合うな。。
exports.mapToBindProc = (source$, sink, bindArg) => source$.pipe(operators_1.map((data) => sink([data, bindArg])));
exports.latestProc = (source$, sink, latest$) => source$.pipe(operators_1.withLatestFrom(latest$), operators_1.map(([, latest]) => sink(latest)));
exports.withLatestProc = (source$, sink, latests$) => source$.pipe(operators_1.withLatestFrom(...latests$), operators_1.map((data) => sink(data)));
exports.latestMapProc = (source$, sink, latests$, fn) => source$.pipe(operators_1.withLatestFrom(...latests$), operators_1.map((data) => sink(fn(data))));
exports.createLatestMapProc = (fn) => (source$, sink, latests$ = []) => exports.latestMapProc(source$, sink, latests$, fn);
exports.latestMergeMapProc = (source$, sink, latests$, fn, errSink) => source$.pipe(operators_1.withLatestFrom(...latests$), mergeMapOperator(fn, sink, errSink));
exports.createLatestMergeMapProc = (fn) => (source$, sink, latests$, errSink) => exports.latestMergeMapProc(source$, sink, latests$, fn, errSink);
exports.fromEventProc = (source$, sink, eventName) => source$.pipe(operators_1.mergeMap((target) => rxjs_1.fromEvent(target, eventName)), operators_1.map((data) => sink(data)));
const defaultPatchFn = (data) => data;
exports.pickProc = (source$, sink, query, patch = defaultPatchFn) => source$.pipe(operators_1.mergeMap((data) => rxjs_1.of(data).pipe(operators_1.map((data) => query(data)), operators_1.filter((data) => data !== undefined), operators_1.catchError(() => rxjs_1.of(data).pipe(operators_1.filter(() => false))), operators_1.map((data) => sink(patch(data))))));
exports.intervalMapToProc = (running$, sink, interval, data) => running$.pipe(operators_1.filter((running) => running), operators_1.switchMap(() => rxjs_1.timer(0, interval).pipe(operators_1.map(() => sink(data)), operators_1.takeUntil(running$.pipe(operators_1.filter((running) => !running))))));
exports.intervalLatestMapProc = (running$, sink, fn, interval = 1000, latests$ = []) => running$.pipe(operators_1.filter((running) => running), operators_1.switchMap(() => rxjs_1.timer(0, interval).pipe(operators_1.withLatestFrom(...latests$), operators_1.map((data) => sink(fn(data))))));
exports.zipMergeMapProc = (source$, sink, sources$, fn) => rxjs_1.zip(source$, ...sources$).pipe(operators_1.mergeMap((data) => fn(data)), operators_1.map(data => sink(data)));
exports.groupProc = (source$, sink, groupFunc) => source$.pipe(operators_1.groupBy(groupFunc), operators_1.map(group$ => sink(group$)));
exports.createGroupProc = (groupFn) => (source$, sink) => exports.groupProc(source$, sink, groupFn);
exports.exposeGroupProc = (source$, sink, key) => source$.pipe(operators_1.filter((group$) => group$.key === key), operators_1.mergeMap((group$) => group$), operators_1.map((data) => sink(data)));
//# sourceMappingURL=processors.js.map